package shell

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/donbowman/github-multi-account-manager/internal/config"
)

// ShellType represents the type of shell
type ShellType string

const (
	ShellZsh        ShellType = "zsh"
	ShellBash       ShellType = "bash"
	ShellFish       ShellType = "fish"
	ShellPowerShell ShellType = "powershell"
)

// Manager handles shell configuration
type Manager struct {
	ShellType  ShellType
	ConfigFile string
}

// New creates a new shell manager
func New() (*Manager, error) {
	shellType := detectShell()
	configFile := getConfigFile(shellType)

	return &Manager{
		ShellType:  shellType,
		ConfigFile: configFile,
	}, nil
}

// detectShell detects the current shell
func detectShell() ShellType {
	// Windows: Use PowerShell
	if runtime.GOOS == "windows" {
		return ShellPowerShell
	}

	shell := os.Getenv("SHELL")

	if strings.Contains(shell, "zsh") {
		return ShellZsh
	} else if strings.Contains(shell, "bash") {
		return ShellBash
	} else if strings.Contains(shell, "fish") {
		return ShellFish
	}

	// Default to bash
	return ShellBash
}

// getConfigFile returns the config file path for the given shell
func getConfigFile(shellType ShellType) string {
	home, _ := os.UserHomeDir()

	switch shellType {
	case ShellZsh:
		return filepath.Join(home, ".zshrc")
	case ShellBash:
		return filepath.Join(home, ".bashrc")
	case ShellFish:
		return filepath.Join(home, ".config", "fish", "config.fish")
	case ShellPowerShell:
		// PowerShell profile location
		return filepath.Join(home, "Documents", "PowerShell", "Microsoft.PowerShell_profile.ps1")
	default:
		return filepath.Join(home, ".bashrc")
	}
}

// GenerateGCloneFunction generates the smart gclone function
func (m *Manager) GenerateGCloneFunction(accounts []config.Account, defaultAccount string) string {
	switch m.ShellType {
	case ShellFish:
		return m.generateFishFunction(accounts, defaultAccount)
	case ShellPowerShell:
		return m.generatePowerShellFunction(accounts, defaultAccount)
	default:
		return m.generatePOSIXFunction(accounts, defaultAccount)
	}
}

// generatePOSIXFunction generates gclone for bash/zsh
func (m *Manager) generatePOSIXFunction(accounts []config.Account, defaultAccount string) string {
	var caseStatements []string
	defaultHost := "github.com"

	for _, account := range accounts {
		isDefault := (defaultAccount == account.Name)
		if isDefault {
			defaultHost = account.HostAlias
		}

		caseStatements = append(caseStatements, fmt.Sprintf(`        *%s*)
            host="%s"
            echo "ðŸ”‘ Cloning with %s account..."
            ;;`, account.Directory, account.HostAlias, account.Name))
	}

	cases := strings.Join(caseStatements, "\n")

	return fmt.Sprintf(`
# Smart git clone - automatically uses the right GitHub account
# Generated by GitHub Multi-Account Manager (ghmm)
alias gclone='_smart_clone'

_smart_clone() {
    local repo_url="$1"
    
    if [[ -z "$repo_url" ]]; then
        echo "Usage: gclone <github-url>"
        return 1
    fi
    
    # Extract owner/repo from various URL formats
    local owner_repo=""
    if [[ $repo_url =~ github\.com[:/]([^/]+/[^/]+)(\.git)?$ ]]; then
        owner_repo="${BASH_REMATCH[1]%%.git}"
    elif [[ $repo_url =~ ^([^/]+/[^/]+)$ ]]; then
        owner_repo="$repo_url"
    else
        echo "Invalid GitHub URL. Supported formats:"
        echo "  - https://github.com/owner/repo"
        echo "  - git@github.com:owner/repo.git"
        echo "  - owner/repo"
        return 1
    fi
    
    # Determine which host to use based on current directory
    local host="%s"
    case "$PWD" in
%s
        *)
            echo "ðŸ‘¤ Cloning with default account..."
            ;;
    esac
    
    git clone "git@${host}:${owner_repo}.git"
}
`, defaultHost, cases)
}

// generateFishFunction generates gclone for fish shell
func (m *Manager) generateFishFunction(accounts []config.Account, defaultAccount string) string {
	var caseStatements []string
	defaultHost := "github.com"

	for _, account := range accounts {
		isDefault := (defaultAccount == account.Name)
		if isDefault {
			defaultHost = account.HostAlias
		}

		caseStatements = append(caseStatements, fmt.Sprintf(`        case '*%s*'
            set host "%s"
            echo "ðŸ”‘ Cloning with %s account..."
`, account.Directory, account.HostAlias, account.Name))
	}

	return fmt.Sprintf(`
# Smart git clone - automatically uses the right GitHub account
# Generated by GitHub Multi-Account Manager (ghmm)
function gclone
    set repo_url $argv[1]
    
    if test -z "$repo_url"
        echo "Usage: gclone <github-url>"
        return 1
    end
    
    # Extract owner/repo from various URL formats
    set owner_repo ""
    if string match -qr 'github\\.com[:/]([^/]+/[^/]+)(\\.git)?$' $repo_url
        set owner_repo (string replace -r '\\.git$' '' (string match -r 'github\\.com[:/]([^/]+/[^/]+)' $repo_url)[2])
    else if string match -qr '^[^/]+/[^/]+$' $repo_url
        set owner_repo $repo_url
    else
        echo "Invalid GitHub URL. Supported formats:"
        echo "  - https://github.com/owner/repo"
        echo "  - git@github.com:owner/repo.git"
        echo "  - owner/repo"
        return 1
    end
    
    # Determine which host to use based on current directory
    set host "%s"
    switch $PWD
%s        case '*'
            echo "ðŸ‘¤ Cloning with default account..."
    end
    
    git clone "git@$host:$owner_repo.git"
end
`, defaultHost, strings.Join(caseStatements, ""))
}

// generatePowerShellFunction generates gclone for PowerShell
func (m *Manager) generatePowerShellFunction(accounts []config.Account, defaultAccount string) string {
	var switchCases []string
	defaultHost := "github.com"

	for _, account := range accounts {
		isDefault := (defaultAccount == account.Name)
		if isDefault {
			defaultHost = account.HostAlias
		}

		// PowerShell switch case with wildcard matching
		switchCases = append(switchCases, fmt.Sprintf(`        "*%s*" { $host = "%s" }`,
			strings.ReplaceAll(account.Directory, "\\", "\\\\"),
			account.HostAlias))
	}

	return fmt.Sprintf(`
# Smart git clone - automatically uses the right GitHub account
# Generated by GitHub Multi-Account Manager (ghmm)
function gclone {
    param(
        [Parameter(Mandatory=$true)]
        [string]$RepoUrl
    )
    
    # Extract owner/repo from various URL formats
    $ownerRepo = ""
    if ($RepoUrl -match 'github\.com[:/]([^/]+/[^/]+)(\.git)?$') {
        $ownerRepo = $matches[1] -replace '\.git$', ''
    } elseif ($RepoUrl -match '^[^/]+/[^/]+$') {
        $ownerRepo = $RepoUrl
    } else {
        Write-Host "Invalid GitHub URL. Supported formats:"
        Write-Host "  - https://github.com/owner/repo"
        Write-Host "  - git@github.com:owner/repo.git"
        Write-Host "  - owner/repo"
        return
    }
    
    # Determine which host to use based on current directory
    $host = "%s"
    $currentDir = (Get-Location).Path
    switch -Wildcard ($currentDir) {
%s
        default { $host = "%s" }
    }
    
    # Clone with the appropriate host
    $gitUrl = "git@$($host):$ownerRepo.git"
    Write-Host "Cloning from $host..."
    git clone $gitUrl
}
`, defaultHost, strings.Join(switchCases, "\n"), defaultHost)
}

// UpdateShellConfig updates shell config with gclone function
func (m *Manager) UpdateShellConfig(accounts []config.Account, defaultAccount string) error {
	// Ensure PowerShell profile directory exists on Windows
	if m.ShellType == ShellPowerShell {
		profileDir := filepath.Dir(m.ConfigFile)
		if err := os.MkdirAll(profileDir, 0755); err != nil {
			return fmt.Errorf("failed to create PowerShell profile directory: %w", err)
		}
	}

	const (
		startMarker = "# BEGIN GHMM SMART CLONE\n"
		endMarker   = "# END GHMM SMART CLONE\n"
	)

	existingContent := ""

	// Read existing config
	if data, err := os.ReadFile(m.ConfigFile); err == nil {
		content := string(data)

		// Remove old ghmm section if it exists
		if strings.Contains(content, startMarker) {
			parts := strings.Split(content, startMarker)
			before := parts[0]

			afterParts := strings.Split(content, endMarker)
			after := ""
			if len(afterParts) > 1 {
				after = afterParts[1]
			}

			existingContent = before + after
		} else {
			existingContent = content
		}
	}

	// Generate new function
	gcloneFunction := m.GenerateGCloneFunction(accounts, defaultAccount)
	newSection := startMarker + gcloneFunction + endMarker

	// Write updated config
	finalContent := strings.TrimRight(existingContent, "\n") + "\n\n" + newSection

	if err := os.WriteFile(m.ConfigFile, []byte(finalContent), 0644); err != nil {
		return fmt.Errorf("failed to write shell config: %w", err)
	}

	return nil
}

// GetReloadCommand returns the command to reload the shell config
func (m *Manager) GetReloadCommand() string {
	if m.ShellType == ShellPowerShell {
		return ". $PROFILE"
	}
	return fmt.Sprintf("source %s", m.ConfigFile)
}
