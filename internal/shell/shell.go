package shell

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/donbowman/github-multi-account-manager/internal/config"
)

// ShellType represents the type of shell
type ShellType string

const (
	ShellZsh  ShellType = "zsh"
	ShellBash ShellType = "bash"
	ShellFish ShellType = "fish"
)

// Manager handles shell configuration
type Manager struct {
	ShellType  ShellType
	ConfigFile string
}

// New creates a new shell manager
func New() (*Manager, error) {
	shellType := detectShell()
	configFile := getConfigFile(shellType)

	return &Manager{
		ShellType:  shellType,
		ConfigFile: configFile,
	}, nil
}

// detectShell detects the current shell
func detectShell() ShellType {
	shell := os.Getenv("SHELL")

	if strings.Contains(shell, "zsh") {
		return ShellZsh
	} else if strings.Contains(shell, "bash") {
		return ShellBash
	} else if strings.Contains(shell, "fish") {
		return ShellFish
	}

	// Default to bash
	return ShellBash
}

// getConfigFile returns the config file path for the given shell
func getConfigFile(shellType ShellType) string {
	home, _ := os.UserHomeDir()

	switch shellType {
	case ShellZsh:
		return filepath.Join(home, ".zshrc")
	case ShellBash:
		return filepath.Join(home, ".bashrc")
	case ShellFish:
		return filepath.Join(home, ".config", "fish", "config.fish")
	default:
		return filepath.Join(home, ".bashrc")
	}
}

// GenerateGCloneFunction generates the smart gclone function
func (m *Manager) GenerateGCloneFunction(accounts []config.Account, defaultAccount string) string {
	if m.ShellType == ShellFish {
		return m.generateFishFunction(accounts, defaultAccount)
	}
	return m.generatePOSIXFunction(accounts, defaultAccount)
}

// generatePOSIXFunction generates gclone for bash/zsh
func (m *Manager) generatePOSIXFunction(accounts []config.Account, defaultAccount string) string {
	var caseStatements []string
	defaultHost := "github.com"

	for _, account := range accounts {
		isDefault := (defaultAccount == account.Name)
		if isDefault {
			defaultHost = account.HostAlias
		}

		caseStatements = append(caseStatements, fmt.Sprintf(`        *%s*)
            host="%s"
            echo "ðŸ”‘ Cloning with %s account..."
            ;;`, account.Directory, account.HostAlias, account.Name))
	}

	cases := strings.Join(caseStatements, "\n")

	return fmt.Sprintf(`
# Smart git clone - automatically uses the right GitHub account
# Generated by GitHub Multi-Account Manager (ghmm)
alias gclone='_smart_clone'

_smart_clone() {
    local repo_url="$1"
    
    if [[ -z "$repo_url" ]]; then
        echo "Usage: gclone <github-url>"
        return 1
    fi
    
    # Extract owner/repo from various URL formats
    local owner_repo=""
    if [[ $repo_url =~ github\.com[:/]([^/]+/[^/]+)(\.git)?$ ]]; then
        owner_repo="${BASH_REMATCH[1]%%.git}"
    elif [[ $repo_url =~ ^([^/]+/[^/]+)$ ]]; then
        owner_repo="$repo_url"
    else
        echo "Invalid GitHub URL. Supported formats:"
        echo "  - https://github.com/owner/repo"
        echo "  - git@github.com:owner/repo.git"
        echo "  - owner/repo"
        return 1
    fi
    
    # Determine which host to use based on current directory
    local host="%s"
    case "$PWD" in
%s
        *)
            echo "ðŸ‘¤ Cloning with default account..."
            ;;
    esac
    
    git clone "git@${host}:${owner_repo}.git"
}
`, defaultHost, cases)
}

// generateFishFunction generates gclone for fish shell
func (m *Manager) generateFishFunction(accounts []config.Account, defaultAccount string) string {
	var caseStatements []string
	defaultHost := "github.com"

	for _, account := range accounts {
		isDefault := (defaultAccount == account.Name)
		if isDefault {
			defaultHost = account.HostAlias
		}

		caseStatements = append(caseStatements, fmt.Sprintf(`        case '*%s*'
            set host "%s"
            echo "ðŸ”‘ Cloning with %s account..."
`, account.Directory, account.HostAlias, account.Name))
	}

	cases := strings.Join(caseStatements, "\n")

	return fmt.Sprintf(`
# Smart git clone - automatically uses the right GitHub account
# Generated by GitHub Multi-Account Manager (ghmm)
function gclone
    set repo_url $argv[1]
    
    if test -z "$repo_url"
        echo "Usage: gclone <github-url>"
        return 1
    end
    
    # Extract owner/repo from various URL formats
    set owner_repo ""
    if string match -qr 'github\\.com[:/]([^/]+/[^/]+)(\\.git)?$' $repo_url
        set owner_repo (string replace -r '\\.git$' '' (string match -r 'github\\.com[:/]([^/]+/[^/]+)' $repo_url)[2])
    else if string match -qr '^[^/]+/[^/]+$' $repo_url
        set owner_repo $repo_url
    else
        echo "Invalid GitHub URL. Supported formats:"
        echo "  - https://github.com/owner/repo"
        echo "  - git@github.com:owner/repo.git"
        echo "  - owner/repo"
        return 1
    end
    
    # Determine which host to use based on current directory
    set host "%s"
    switch $PWD
%s        case '*'
            echo "ðŸ‘¤ Cloning with default account..."
    end
    
    git clone "git@$host:$owner_repo.git"
end
`, defaultHost, cases)
}

// UpdateShellConfig updates shell config with gclone function
func (m *Manager) UpdateShellConfig(accounts []config.Account, defaultAccount string) error {
	const (
		startMarker = "# BEGIN GHMM SMART CLONE\n"
		endMarker   = "# END GHMM SMART CLONE\n"
	)

	existingContent := ""

	// Read existing config
	if data, err := os.ReadFile(m.ConfigFile); err == nil {
		content := string(data)

		// Remove old ghmm section if it exists
		if strings.Contains(content, startMarker) {
			parts := strings.Split(content, startMarker)
			before := parts[0]

			afterParts := strings.Split(content, endMarker)
			after := ""
			if len(afterParts) > 1 {
				after = afterParts[1]
			}

			existingContent = before + after
		} else {
			existingContent = content
		}
	}

	// Generate new function
	gcloneFunction := m.GenerateGCloneFunction(accounts, defaultAccount)
	newSection := startMarker + gcloneFunction + endMarker

	// Write updated config
	finalContent := strings.TrimRight(existingContent, "\n") + "\n\n" + newSection

	if err := os.WriteFile(m.ConfigFile, []byte(finalContent), 0644); err != nil {
		return fmt.Errorf("failed to write shell config: %w", err)
	}

	return nil
}

// GetReloadCommand returns the command to reload the shell config
func (m *Manager) GetReloadCommand() string {
	return fmt.Sprintf("source %s", m.ConfigFile)
}
