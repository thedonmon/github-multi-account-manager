package ssh

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/donbowman/github-multi-account-manager/internal/config"
)

// Manager handles SSH key operations
type Manager struct {
	sshDir     string
	configFile string
}

// New creates a new SSH manager
func New() (*Manager, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get home directory: %w", err)
	}

	sshDir := filepath.Join(home, ".ssh")

	// Create .ssh directory if it doesn't exist
	if err := os.MkdirAll(sshDir, 0700); err != nil {
		return nil, fmt.Errorf("failed to create .ssh directory: %w", err)
	}

	return &Manager{
		sshDir:     sshDir,
		configFile: filepath.Join(sshDir, "config"),
	}, nil
}

// GenerateKey generates a new SSH key
func (m *Manager) GenerateKey(keyPath, email, keyType string) error {
	if keyType == "" {
		keyType = "ed25519"
	}

	// Expand home directory
	if strings.HasPrefix(keyPath, "~/") {
		home, _ := os.UserHomeDir()
		keyPath = filepath.Join(home, keyPath[2:])
	}

	// Check if key already exists
	if _, err := os.Stat(keyPath); err == nil {
		return fmt.Errorf("key already exists at %s", keyPath)
	}

	// Generate the key
	cmd := exec.Command("ssh-keygen",
		"-t", keyType,
		"-C", email,
		"-f", keyPath,
		"-N", "", // No passphrase
	)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to generate key: %s", string(output))
	}

	// Set proper permissions
	if err := os.Chmod(keyPath, 0600); err != nil {
		return fmt.Errorf("failed to set key permissions: %w", err)
	}

	return nil
}

// GetPublicKey returns the content of the public key
func (m *Manager) GetPublicKey(keyPath string) (string, error) {
	// Expand home directory
	if strings.HasPrefix(keyPath, "~/") {
		home, _ := os.UserHomeDir()
		keyPath = filepath.Join(home, keyPath[2:])
	}

	pubKeyPath := keyPath + ".pub"

	data, err := os.ReadFile(pubKeyPath)
	if err != nil {
		return "", fmt.Errorf("failed to read public key: %w", err)
	}

	return strings.TrimSpace(string(data)), nil
}

// TestConnection tests SSH connection to GitHub
func (m *Manager) TestConnection(hostAlias string) (bool, string) {
	cmd := exec.Command("ssh", "-T", fmt.Sprintf("git@%s", hostAlias))

	// Set a timeout
	timer := time.AfterFunc(10*time.Second, func() {
		cmd.Process.Kill()
	})
	defer timer.Stop()

	output, err := cmd.CombinedOutput()
	outputStr := string(output)

	// GitHub returns exit code 1 for successful auth (no shell access)
	if strings.Contains(strings.ToLower(outputStr), "successfully authenticated") {
		return true, strings.TrimSpace(outputStr)
	}

	if err != nil {
		if strings.Contains(outputStr, "") {
			return false, strings.TrimSpace(outputStr)
		}
		return false, fmt.Sprintf("Connection failed: %v", err)
	}

	return false, "Connection failed"
}

// AddToSSHAgent adds an SSH key to ssh-agent
func (m *Manager) AddToSSHAgent(keyPath string) error {
	// Expand home directory
	if strings.HasPrefix(keyPath, "~/") {
		home, _ := os.UserHomeDir()
		keyPath = filepath.Join(home, keyPath[2:])
	}

	// Check if key exists
	if _, err := os.Stat(keyPath); err != nil {
		return fmt.Errorf("key not found at %s", keyPath)
	}

	// Add the key
	cmd := exec.Command("ssh-add", keyPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to add key: %s", string(output))
	}

	return nil
}

// UpdateSSHConfig updates ~/.ssh/config with account configurations
func (m *Manager) UpdateSSHConfig(accounts []config.Account) error {
	const (
		startMarker = "# BEGIN GHMM MANAGED SECTION\n"
		endMarker   = "# END GHMM MANAGED SECTION\n"
	)

	existingContent := ""

	// Read existing config
	if data, err := os.ReadFile(m.configFile); err == nil {
		content := string(data)

		// Remove old ghmm section if it exists
		if strings.Contains(content, startMarker) {
			parts := strings.Split(content, startMarker)
			before := parts[0]

			afterParts := strings.Split(content, endMarker)
			after := ""
			if len(afterParts) > 1 {
				after = afterParts[1]
			}

			existingContent = before + after
		} else {
			existingContent = content
		}
	}

	// Generate new config section
	var newSection strings.Builder
	newSection.WriteString(startMarker)
	newSection.WriteString("# Generated by GitHub Multi-Account Manager\n")
	newSection.WriteString("# Do not edit this section manually\n\n")

	for _, account := range accounts {
		newSection.WriteString(fmt.Sprintf("# %s account\n", account.Name))
		newSection.WriteString(fmt.Sprintf("Host %s\n", account.HostAlias))
		newSection.WriteString("   HostName github.com\n")
		newSection.WriteString("   User git\n")
		newSection.WriteString(fmt.Sprintf("   IdentityFile %s\n", account.SSHKeyPath))
		newSection.WriteString("   IdentitiesOnly yes\n\n")
	}

	newSection.WriteString(endMarker)

	// Write updated config
	finalContent := strings.TrimRight(existingContent, "\n") + "\n\n" + newSection.String()

	if err := os.WriteFile(m.configFile, []byte(finalContent), 0600); err != nil {
		return fmt.Errorf("failed to write SSH config: %w", err)
	}

	return nil
}
