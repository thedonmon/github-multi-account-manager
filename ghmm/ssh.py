"""SSH key management for ghmm."""

import os
import subprocess
from pathlib import Path
from typing import Optional, Tuple


class SSHManager:
    """Manages SSH keys and configuration."""

    def __init__(self):
        self.ssh_dir = Path.home() / ".ssh"
        self.ssh_config = self.ssh_dir / "config"
        self.ssh_dir.mkdir(mode=0o700, exist_ok=True)

    def generate_key(
        self, key_path: str, email: str, key_type: str = "ed25519"
    ) -> Tuple[bool, str]:
        """Generate a new SSH key.
        
        Returns:
            Tuple of (success, message)
        """
        key_path_obj = Path(key_path).expanduser()
        
        # Check if key already exists
        if key_path_obj.exists():
            return False, f"Key already exists at {key_path_obj}"

        try:
            # Generate the key
            result = subprocess.run(
                [
                    "ssh-keygen",
                    "-t", key_type,
                    "-C", email,
                    "-f", str(key_path_obj),
                    "-N", "",  # No passphrase
                ],
                capture_output=True,
                text=True,
                check=True,
            )
            
            # Set proper permissions
            key_path_obj.chmod(0o600)
            
            return True, f"Key generated successfully at {key_path_obj}"
        except subprocess.CalledProcessError as e:
            return False, f"Failed to generate key: {e.stderr}"

    def get_public_key(self, key_path: str) -> Optional[str]:
        """Get the public key content."""
        pub_key_path = Path(key_path).expanduser().with_suffix(".pub")
        
        if not pub_key_path.exists():
            return None
        
        return pub_key_path.read_text().strip()

    def test_connection(self, host_alias: str) -> Tuple[bool, str]:
        """Test SSH connection to GitHub.
        
        Returns:
            Tuple of (success, message)
        """
        try:
            result = subprocess.run(
                ["ssh", "-T", f"git@{host_alias}"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            
            # GitHub returns exit code 1 for successful auth (no shell access)
            if "successfully authenticated" in result.stderr.lower():
                return True, result.stderr.strip()
            else:
                return False, result.stderr.strip() or "Connection failed"
        except subprocess.TimeoutExpired:
            return False, "Connection timeout"
        except Exception as e:
            return False, f"Connection error: {str(e)}"

    def add_to_ssh_agent(self, key_path: str) -> Tuple[bool, str]:
        """Add SSH key to ssh-agent.
        
        Returns:
            Tuple of (success, message)
        """
        key_path_obj = Path(key_path).expanduser()
        
        if not key_path_obj.exists():
            return False, f"Key not found at {key_path_obj}"
        
        try:
            # Start ssh-agent if not running
            subprocess.run(["ssh-add", "-l"], capture_output=True, check=False)
            
            # Add the key
            result = subprocess.run(
                ["ssh-add", str(key_path_obj)],
                capture_output=True,
                text=True,
                check=True,
            )
            
            return True, "Key added to ssh-agent"
        except subprocess.CalledProcessError as e:
            return False, f"Failed to add key: {e.stderr}"

    def update_ssh_config(self, accounts: list) -> Tuple[bool, str]:
        """Update ~/.ssh/config with account configurations.
        
        Returns:
            Tuple of (success, message)
        """
        try:
            # Read existing config
            existing_content = ""
            ghmm_start_marker = "# BEGIN GHMM MANAGED SECTION\n"
            ghmm_end_marker = "# END GHMM MANAGED SECTION\n"
            
            if self.ssh_config.exists():
                content = self.ssh_config.read_text()
                
                # Remove old ghmm section if it exists
                if ghmm_start_marker in content:
                    before = content.split(ghmm_start_marker)[0]
                    after_parts = content.split(ghmm_end_marker)
                    after = after_parts[1] if len(after_parts) > 1 else ""
                    existing_content = before + after
                else:
                    existing_content = content
            
            # Generate new config section
            new_section = ghmm_start_marker
            new_section += "# Generated by GitHub Multi-Account Manager\n"
            new_section += "# Do not edit this section manually\n\n"
            
            for account in accounts:
                new_section += f"# {account['name']} account\n"
                new_section += f"Host {account['host_alias']}\n"
                new_section += f"   HostName github.com\n"
                new_section += f"   User git\n"
                new_section += f"   IdentityFile {account['ssh_key_path']}\n"
                new_section += f"   IdentitiesOnly yes\n\n"
            
            new_section += ghmm_end_marker
            
            # Write updated config
            final_content = existing_content.rstrip() + "\n\n" + new_section
            self.ssh_config.write_text(final_content)
            self.ssh_config.chmod(0o600)
            
            return True, f"SSH config updated with {len(accounts)} account(s)"
        except Exception as e:
            return False, f"Failed to update SSH config: {str(e)}"

    def remove_from_ssh_config(self, host_alias: str) -> Tuple[bool, str]:
        """Remove a specific host from SSH config (handled by update_ssh_config)."""
        # This is now handled by update_ssh_config which regenerates the entire section
        return True, "Config will be updated on next save"
